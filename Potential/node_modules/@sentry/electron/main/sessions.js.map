{"version":3,"file":"sessions.js","sources":["../src/src/main/sessions.ts"],"sourcesContent":["import {\n  captureSession,\n  endSession as endSessionCore,\n  getClient,\n  getCurrentScope,\n  makeSession,\n  startSession as startSessionCore,\n  updateSession,\n} from '@sentry/core';\nimport { flush, NodeClient } from '@sentry/node';\nimport { SerializedSession, Session, SessionContext, SessionStatus } from '@sentry/types';\nimport { logger } from '@sentry/utils';\nimport { app } from 'electron';\n\nimport { getSentryCachePath } from './electron-normalize';\nimport { Store } from './store';\n\nconst PERSIST_INTERVAL_MS = 60_000;\n\n/** Stores the app session in case of termination due to main process crash or app killed */\nlet sessionStore: Store<SessionContext | undefined> | undefined;\n/** Previous session if it did not exit cleanly */\nlet previousSession: Promise<Partial<Session> | undefined> | undefined;\n\nfunction getSessionStore(): Store<SessionContext | undefined> {\n  if (!sessionStore) {\n    sessionStore = new Store<SessionContext | undefined>(getSentryCachePath(), 'session', undefined);\n    previousSession = sessionStore.get();\n  }\n\n  return sessionStore;\n}\n\nlet persistTimer: ReturnType<typeof setInterval> | undefined;\n\n/** Starts a session */\nexport function startSession(sendOnCreate: boolean): void {\n  const session = startSessionCore();\n\n  if (sendOnCreate) {\n    captureSession();\n  }\n\n  getSessionStore()\n    .set(session)\n    .catch(() => {\n      // Does not throw\n    });\n\n  // Every PERSIST_INTERVAL, write the session to disk\n  persistTimer = setInterval(async () => {\n    const currentSession = getCurrentScope().getSession();\n    // Only bother saving if it hasn't already ended\n    if (currentSession && currentSession.status === 'ok') {\n      await getSessionStore().set(currentSession);\n    }\n  }, PERSIST_INTERVAL_MS);\n}\n\n/** Cleanly ends a session */\nexport async function endSession(): Promise<void> {\n  // Once the session had ended there is no point persisting it\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getCurrentScope().getSession();\n\n  if (session) {\n    if (session.status === 'ok') {\n      logger.log('Ending session');\n      endSessionCore();\n    } else {\n      logger.log('Session was already ended');\n    }\n  } else {\n    logger.log('No session');\n  }\n\n  await getSessionStore().clear();\n\n  await flush(2_000);\n}\n\n/** Determines if a Date is likely to have occurred in the previous uncompleted session */\nexport async function unreportedDuringLastSession(crashDate: Date | undefined): Promise<boolean> {\n  if (!crashDate) {\n    return false;\n  }\n\n  const previousSessionModified = await getSessionStore().getModifiedDate();\n  // There is no previous session\n  if (previousSessionModified === undefined) {\n    return false;\n  }\n\n  const previousSessionModifiedTime = previousSessionModified.getTime();\n  const crashTime = crashDate.getTime();\n\n  // Session could have run until modified time + persist interval\n  const prevSessionEnd = previousSessionModifiedTime + PERSIST_INTERVAL_MS;\n\n  // Event cannot have occurred before last persist time, We add a 2 second overlap to be sure\n  const lastPersist = previousSessionModifiedTime - 2_000;\n\n  // If the crash occurred between the last persist and estimated end of session\n  return crashTime > lastPersist && crashTime < prevSessionEnd;\n}\n\n/** Checks if the previous session needs sending as crashed or abnormal  */\nexport async function checkPreviousSession(crashed: boolean): Promise<void> {\n  const client = getClient<NodeClient>();\n\n  const previous = await previousSession;\n\n  if (previous && client) {\n    // Ignore if the previous session is already ended\n    if (previous.status !== 'ok') {\n      previousSession = undefined;\n      return;\n    }\n\n    const status: SessionStatus = crashed ? 'crashed' : 'abnormal';\n\n    logger.log(`Found previous ${status} session`);\n\n    const sesh = makeSession(previous);\n\n    updateSession(sesh, {\n      status,\n      errors: (sesh.errors || 0) + 1,\n      release: (previous as unknown as SerializedSession).attrs?.release,\n      environment: (previous as unknown as SerializedSession).attrs?.environment,\n    });\n\n    await client.sendSession(sesh);\n\n    previousSession = undefined;\n  }\n}\n\n/** Sets the current session as crashed */\nexport function sessionCrashed(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  logger.log('Session Crashed');\n  const session = getCurrentScope().getSession();\n\n  if (!session) {\n    logger.log('No session to update');\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as crashed');\n    const errors = session.errors + 1;\n    updateSession(session, { status: 'crashed', errors });\n    captureSession();\n  } else {\n    logger.log('Session already ended');\n  }\n}\n\n/** Sets the current session as ANR */\nexport function sessionAnr(): void {\n  // stop persisting session\n  if (persistTimer) {\n    clearInterval(persistTimer);\n  }\n\n  const session = getCurrentScope().getSession();\n\n  if (!session) {\n    return;\n  }\n\n  if (session.status === 'ok') {\n    logger.log('Setting session as abnormal ANR');\n    updateSession(session, { status: 'abnormal', abnormal_mechanism: 'anr_foreground' });\n    captureSession();\n  }\n}\n\n/**\n * End the current session on app exit\n */\nexport function endSessionOnExit(): void {\n  // 'before-quit' is always called before 'will-quit' so we listen there and ensure our 'will-quit' handler is still\n  // the last listener\n  app.on('before-quit', () => {\n    // We track the end of sessions via the 'will-quit' event which is the last event emitted before close.\n    //\n    // We need to be the last 'will-quit' listener so as not to interfere with any user defined listeners which may\n    // call `event.preventDefault()` to abort the exit.\n    app.removeListener('will-quit', exitHandler);\n    app.on('will-quit', exitHandler);\n  });\n}\n\n/** Handles the exit */\nconst exitHandler: (event: Electron.Event) => Promise<void> = async (event: Electron.Event) => {\n  if (event.defaultPrevented) {\n    return;\n  }\n\n  logger.log('[Session] Exit Handler');\n\n  // Stop the exit so we have time to send the session\n  event.preventDefault();\n\n  try {\n    // End the session\n    await endSession();\n  } catch (e) {\n    // Ignore and log any errors which would prevent app exit\n    logger.warn('[Session] Error ending session:', e);\n  }\n\n  app.exit();\n};\n"],"names":["Store","getSentryCachePath","startSessionCore","captureSession","getCurrentScope","logger","endSessionCore","flush","getClient","makeSession","updateSession","app"],"mappings":"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"}