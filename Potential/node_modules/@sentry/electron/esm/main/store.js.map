{"version":3,"file":"store.js","sources":["../../src/main/store.ts"],"sourcesContent":["import { logger } from '@sentry/utils';\nimport { promises as fs } from 'fs';\nimport { dirname, join } from 'path';\n\nimport { Mutex } from './mutex';\n\nconst dateFormat = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.*\\d{0,10}Z$/;\n\n/** JSON revive function to enable de-serialization of Date objects */\nfunction dateReviver(_: string, value: any): any {\n  if (typeof value === 'string' && dateFormat.test(value)) {\n    return new Date(value);\n  }\n\n  return value;\n}\n\n/**\n * Stores data serialized to a JSON file.\n */\nexport class Store<T> {\n  /** Current state of the data. */\n  protected _data?: T;\n\n  /** Internal path for JSON file. */\n  private readonly _path: string;\n  /** Value used to initialize data for the first time. */\n  private readonly _initial: T;\n  /** A mutex to ensure that there aren't races while reading and writing files */\n  private readonly _lock: Mutex;\n\n  /**\n   * Creates a new store.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   */\n  public constructor(path: string, id: string, initial: T) {\n    this._lock = new Mutex();\n    this._path = join(path, `${id}.json`);\n    this._initial = initial;\n  }\n\n  /**\n   * Updates data by replacing it with the given value.\n   * @param data New data to replace the previous one.\n   */\n  public async set(data: T): Promise<void> {\n    await this._lock.runExclusive(async () => {\n      this._data = data;\n\n      try {\n        if (data === undefined) {\n          try {\n            await fs.unlink(this._path);\n          } catch (_) {\n            //\n          }\n        } else {\n          await fs.mkdir(dirname(this._path), { recursive: true });\n          await fs.writeFile(this._path, JSON.stringify(data));\n        }\n      } catch (e) {\n        logger.warn('Failed to write to store', e);\n        // This usually fails due to anti virus scanners, issues in the file\n        // system, or problems with network drives. We cannot fix or handle this\n        // issue and must resume gracefully. Thus, we have to ignore this error.\n      }\n    });\n  }\n\n  /**\n   * Returns the current data.\n   *\n   * When invoked for the first time, it will try to load previously stored data\n   * from disk. If the file does not exist, the initial value provided to the\n   * constructor is used.\n   */\n  public async get(): Promise<T> {\n    return this._lock.runExclusive(async () => {\n      if (this._data === undefined) {\n        try {\n          this._data = JSON.parse(await fs.readFile(this._path, 'utf8'), dateReviver) as T;\n        } catch (e) {\n          this._data = this._initial;\n        }\n      }\n\n      return this._data;\n    });\n  }\n\n  /**\n   * Updates data by passing it through the given function.\n   * @param fn A function receiving the current data and returning new one.\n   */\n  public async update(fn: (current: T) => T): Promise<void> {\n    await this.set(fn(await this.get()));\n  }\n\n  /** Returns store to its initial state */\n  public async clear(): Promise<void> {\n    await this.set(this._initial);\n  }\n\n  /** Gets the Date that the file was last modified */\n  public async getModifiedDate(): Promise<Date | undefined> {\n    try {\n      return (await fs.stat(this._path))?.mtime;\n    } catch (_) {\n      return undefined;\n    }\n  }\n}\n\n/**\n * Extends Store to throttle writes.\n */\nexport class BufferedWriteStore<T> extends Store<T> {\n  /** A write that hasn't been written to disk yet */\n  private _pendingWrite: { data: T; timeout: NodeJS.Timeout } | undefined;\n\n  /**\n   * Creates a new ThrottledStore.\n   *\n   * @param path A unique filename to store this data.\n   * @param id A unique filename to store this data.\n   * @param initial An initial value to initialize data with.\n   * @param throttleTime The minimum time between writes\n   */\n  public constructor(path: string, id: string, initial: T, private readonly _throttleTime: number = 500) {\n    super(path, id, initial);\n  }\n\n  /** @inheritdoc */\n  public override async set(data: T): Promise<void> {\n    this._data = data;\n\n    this._pendingWrite = {\n      // We overwrite the data for the pending write so that the latest data is written in the next flush\n      data,\n      // If there is already a pending timeout, we keep that rather than starting the timeout again\n      timeout: this._pendingWrite?.timeout || setTimeout(() => this._writePending(), this._throttleTime),\n    };\n  }\n\n  /** Writes the pending write to disk */\n  private _writePending(): void {\n    if (this._pendingWrite) {\n      const data = this._pendingWrite.data;\n      // Clear the pending write immediately so that subsequent writes can be queued\n      this._pendingWrite = undefined;\n      super.set(data).catch(() => {\n        // ignore\n      });\n    }\n  }\n}\n"],"names":["fs"],"mappings":"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"}