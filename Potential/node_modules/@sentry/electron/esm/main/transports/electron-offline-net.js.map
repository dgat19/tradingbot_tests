{"version":3,"file":"electron-offline-net.js","sources":["../../../src/main/transports/electron-offline-net.ts"],"sourcesContent":["import { makeOfflineTransport, OfflineTransportOptions } from '@sentry/core';\nimport { BaseTransportOptions, Envelope, Transport } from '@sentry/types';\n\nimport { ElectronNetTransportOptions, makeElectronTransport } from './electron-net';\nimport { createOfflineStore, OfflineStoreOptions } from './offline-store';\n\nexport type ElectronOfflineTransportOptions = ElectronNetTransportOptions &\n  OfflineTransportOptions &\n  Partial<OfflineStoreOptions> & {\n    /**\n     * Should we attempt to send the envelope to Sentry.\n     * If this function returns false, `shouldStore` will be called to determine if the envelope should be stored.\n     *\n     * Default: () => true\n     *\n     * @param envelope The envelope that will be sent.\n     * @returns Whether we should attempt to send the envelope\n     */\n    shouldSend?: (envelope: Envelope) => boolean | Promise<boolean>;\n  };\n\n// Transport that throws if the `shouldSend` callback returns false\nfunction makeShouldSendTransport<T extends BaseTransportOptions>(\n  baseTransport: (opt: T & ElectronOfflineTransportOptions) => Transport,\n): (options: T & ElectronOfflineTransportOptions) => Transport {\n  return (options: T & ElectronOfflineTransportOptions) => {\n    const transport = baseTransport(options);\n\n    return {\n      ...transport,\n      send: async (envelope) => {\n        const shouldAttemptSend = options.shouldSend === undefined || (await options.shouldSend(envelope));\n\n        if (shouldAttemptSend) {\n          return transport.send(envelope);\n        }\n\n        throw new Error(\"'shouldSend' callback returned false. Skipped sending.\");\n      },\n    };\n  };\n}\n\n/**\n * Creates a Transport that uses Electrons net module to send events to Sentry. When they fail to send they are\n * persisted to disk and sent later\n */\nexport function makeElectronOfflineTransport<T extends BaseTransportOptions>(\n  baseTransport: (opt: T & ElectronOfflineTransportOptions) => Transport = makeElectronTransport,\n): (options: T & ElectronOfflineTransportOptions) => Transport {\n  return (userOptions: T & ElectronOfflineTransportOptions): Transport => {\n    // `makeElectronOfflineTransport` is a combination of three transports.\n    //\n    // The base Electron transport (`makeElectronTransport`) is first wrapped by `makeShouldSendTransport` which skips\n    // sending events and throws when the `shouldSend` callback returns false.\n    //\n    // This is then wrapped again by `makeOfflineTransport` which stores events to disk when they fail to send.\n    return makeOfflineTransport(makeShouldSendTransport(baseTransport))({\n      flushAtStartup: true,\n      createStore: createOfflineStore,\n      ...userOptions,\n    });\n  };\n}\n"],"names":[],"mappings":";;;;AAqBA;AACA,SAAS,uBAAuB,CAC9B,aAAsE,EAAA;IAEtE,OAAO,CAAC,OAA4C,KAAI;AACtD,QAAA,MAAM,SAAS,GAAG,aAAa,CAAC,OAAO,CAAC;QAExC,OAAO;AACL,YAAA,GAAG,SAAS;AACZ,YAAA,IAAI,EAAE,OAAO,QAAQ,KAAI;AACvB,gBAAA,MAAM,iBAAiB,GAAG,OAAO,CAAC,UAAU,KAAK,SAAS,KAAK,MAAM,OAAO,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC;AAElG,gBAAA,IAAI,iBAAiB,EAAE;AACrB,oBAAA,OAAO,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC;AAChC;AAED,gBAAA,MAAM,IAAI,KAAK,CAAC,wDAAwD,CAAC;aAC1E;SACF;AACH,KAAC;AACH;AAEA;;;AAGG;AACa,SAAA,4BAA4B,CAC1C,aAAA,GAAyE,qBAAqB,EAAA;IAE9F,OAAO,CAAC,WAAgD,KAAe;;;;;;;AAOrE,QAAA,OAAO,oBAAoB,CAAC,uBAAuB,CAAC,aAAa,CAAC,CAAC,CAAC;AAClE,YAAA,cAAc,EAAE,IAAI;AACpB,YAAA,WAAW,EAAE,kBAAkB;AAC/B,YAAA,GAAG,WAAW;AACf,SAAA,CAAC;AACJ,KAAC;AACH;;;;"}