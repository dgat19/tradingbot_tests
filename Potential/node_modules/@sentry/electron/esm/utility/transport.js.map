{"version":3,"file":"transport.js","sources":["../../src/utility/transport.ts"],"sourcesContent":["import { createTransport } from '@sentry/core';\nimport { BaseTransportOptions, Transport, TransportMakeRequestResponse, TransportRequest } from '@sentry/types';\n\nimport { getMagicMessage, isMagicMessage } from '../common/ipc';\n\n/**\n * Creates a Transport that passes envelopes to the Electron main process.\n */\nexport function makeUtilityProcessTransport(): (options: BaseTransportOptions) => Transport {\n  let mainMessagePort: Electron.MessagePortMain | undefined;\n\n  async function sendEnvelope(envelope: string | Uint8Array): Promise<void> {\n    let count = 0;\n\n    // mainMessagePort is undefined until the main process sends us the message port\n    while (mainMessagePort === undefined) {\n      await new Promise((resolve) => setTimeout(resolve, 100));\n      count += 1;\n\n      // After 5 seconds, we give up waiting for the main process to send us the message port\n      if (count >= 50) {\n        throw new Error('Timeout waiting for message port to send event to main process');\n      }\n    }\n\n    mainMessagePort.postMessage(envelope);\n  }\n\n  // Receive the messageport from the main process\n  process.parentPort.on('message', (msg) => {\n    if (isMagicMessage(msg.data)) {\n      const [port] = msg.ports;\n      mainMessagePort = port;\n      mainMessagePort?.start();\n    }\n  });\n\n  // We proxy `process.parentPort.on` so we can filter messages from the main SDK and ensure that users do not see them\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  process.parentPort.on = new Proxy(process.parentPort.on, {\n    apply: (target, thisArg, [event, listener]) => {\n      if (event === 'message') {\n        return target.apply(thisArg, [\n          'message',\n          (msg: MessageEvent) => {\n            if (isMagicMessage(msg.data)) {\n              return;\n            }\n\n            return listener(msg);\n          },\n        ]);\n      }\n\n      return target.apply(thisArg, [event, listener]);\n    },\n  });\n\n  // Notify the main process that this utility process has started with an SDK configured\n  process.parentPort.postMessage(getMagicMessage());\n\n  return (options) => {\n    return createTransport(options, async (request: TransportRequest): Promise<TransportMakeRequestResponse> => {\n      await sendEnvelope(request.body);\n      // Since the main process handles sending of envelopes and rate limiting, we always return 200 OK\n      return { statusCode: 200 };\n    });\n  };\n}\n"],"names":[],"mappings":";;;AAKA;;AAEG;SACa,2BAA2B,GAAA;AACzC,IAAA,IAAI,eAAqD;IAEzD,eAAe,YAAY,CAAC,QAA6B,EAAA;QACvD,IAAI,KAAK,GAAG,CAAC;;QAGb,OAAO,eAAe,KAAK,SAAS,EAAE;AACpC,YAAA,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,KAAK,UAAU,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;YACxD,KAAK,IAAI,CAAC;;YAGV,IAAI,KAAK,IAAI,EAAE,EAAE;AACf,gBAAA,MAAM,IAAI,KAAK,CAAC,gEAAgE,CAAC;AAClF;AACF;AAED,QAAA,eAAe,CAAC,WAAW,CAAC,QAAQ,CAAC;;;IAIvC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,SAAS,EAAE,CAAC,GAAG,KAAI;AACvC,QAAA,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;AAC5B,YAAA,MAAM,CAAC,IAAI,CAAC,GAAG,GAAG,CAAC,KAAK;YACxB,eAAe,GAAG,IAAI;YACtB,eAAe,EAAE,KAAK,EAAE;AACzB;AACH,KAAC,CAAC;;;AAIF,IAAA,OAAO,CAAC,UAAU,CAAC,EAAE,GAAG,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,EAAE;AACvD,QAAA,KAAK,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,KAAI;YAC5C,IAAI,KAAK,KAAK,SAAS,EAAE;AACvB,gBAAA,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE;oBAC3B,SAAS;oBACT,CAAC,GAAiB,KAAI;AACpB,wBAAA,IAAI,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE;4BAC5B;AACD;AAED,wBAAA,OAAO,QAAQ,CAAC,GAAG,CAAC;qBACrB;AACF,iBAAA,CAAC;AACH;AAED,YAAA,OAAO,MAAM,CAAC,KAAK,CAAC,OAAO,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;SAChD;AACF,KAAA,CAAC;;IAGF,OAAO,CAAC,UAAU,CAAC,WAAW,CAAC,eAAe,EAAE,CAAC;IAEjD,OAAO,CAAC,OAAO,KAAI;QACjB,OAAO,eAAe,CAAC,OAAO,EAAE,OAAO,OAAyB,KAA2C;AACzG,YAAA,MAAM,YAAY,CAAC,OAAO,CAAC,IAAI,CAAC;;AAEhC,YAAA,OAAO,EAAE,UAAU,EAAE,GAAG,EAAE;AAC5B,SAAC,CAAC;AACJ,KAAC;AACH;;;;"}